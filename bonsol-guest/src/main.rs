//! CrypTrans Voting Circuit - RISC Zero Guest Program
//!
//! This program runs inside the RISC Zero zkVM to prove:
//! 1. Voter knows a secret that hashes to their commitment
//! 2. Nullifier is correctly derived from (proposal_id || secret)
//! 3. Vote choice is valid (0 or 1)
//!
//! The STARK proof generated by RISC Zero is then wrapped in a Groth16
//! proof by Bonsol for efficient on-chain verification on Solana.

#![no_main]
#![no_std]

use risc0_zkvm::guest::env;
use sha2::{Sha256, Digest};

risc0_zkvm::guest::entry!(main);

// Note: Unused structs removed to eliminate warnings
// In production, these could be used for typed inputs/outputs

pub fn main() {
    // Read private inputs from zkVM host
    let secret: [u8; 32] = env::read();
    let vote_choice: u8 = env::read();

    // Read public inputs
    let proposal_id: [u8; 32] = env::read();

    // Validate vote choice (must be 0 or 1)
    assert!(vote_choice == 0 || vote_choice == 1, "Invalid vote choice");

    // Compute commitment: SHA256(secret)
    let mut hasher = Sha256::new();
    hasher.update(&secret);
    let commitment = hasher.finalize();
    let commitment_bytes: [u8; 32] = commitment.into();

    // Compute nullifier: SHA256(proposal_id || secret)
    let mut hasher = Sha256::new();
    hasher.update(&proposal_id);
    hasher.update(&secret);
    let nullifier = hasher.finalize();
    let nullifier_bytes: [u8; 32] = nullifier.into();

    // Commit public outputs (these become part of the proof)
    env::commit(&commitment_bytes);
    env::commit(&nullifier_bytes);
    env::commit(&vote_choice);

    // Proof complete! RISC Zero will generate a STARK proof
    // Bonsol will wrap it in Groth16 for on-chain verification
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vote_yes() {
        let secret = [42u8; 32];
        let proposal_id = [1u8; 32];
        let vote_choice = 1u8;

        // This would normally run in zkVM
        // For testing, we just validate the logic
        assert!(vote_choice == 0 || vote_choice == 1);
    }

    #[test]
    fn test_commitment_derivation() {
        use sha2::{Sha256, Digest};

        let secret = [42u8; 32];
        let mut hasher = Sha256::new();
        hasher.update(&secret);
        let commitment = hasher.finalize();

        assert_eq!(commitment.len(), 32);
    }

    #[test]
    fn test_nullifier_derivation() {
        use sha2::{Sha256, Digest};

        let secret = [42u8; 32];
        let proposal_id = [1u8; 32];

        let mut hasher = Sha256::new();
        hasher.update(&proposal_id);
        hasher.update(&secret);
        let nullifier = hasher.finalize();

        assert_eq!(nullifier.len(), 32);

        // Nullifier should be different for different proposals
        let mut hasher2 = Sha256::new();
        let proposal_id2 = [2u8; 32];
        hasher2.update(&proposal_id2);
        hasher2.update(&secret);
        let nullifier2 = hasher2.finalize();

        assert_ne!(nullifier[..], nullifier2[..]);
    }
}
